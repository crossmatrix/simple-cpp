启动顺序
	1.bios(base io system)
	2.bios加载bootloader到内存0x7C00: bootloader位于disk的第一个扇区(引导扇区)(512byte)，并跳转到0000:7C00
	3.bootloader加载os代码和数据到内存，并跳转到操作系统起始地址
	
16进制，4bit
	0	0000	0
	1 	0001	1
	2 	0010	2
	3 	0011	3
	4	0100	4
	5	0101	5
	6	0110	6
	7	0111	7
	8	1000	8
	9	1001	9
	10	1010	A
	11	1011	B
	12	1100	C
	13	1101	D
	14	1110	E
	15	1111	F
	
有符号数和无符号数
		8|7
	B			4
	C			3
		F|0
	//有符号中：F = -1，8 = -8
	1000
	0111
	1000
	
		80|7F
	BF			40
	C0			3F
		FF|0
	//有符号中：7F = 127，FF = -1，80 = -128
	
--------------
	q1: 8进制，2 - 5 = 1 777 777 777 777 777 777 775
			0010
		-	0101
		--------------
		  (b1101)		(->	~(1101-1) = 0011 -> -3)		(015)
	q2: xor加密87AD6，然后解密，密钥55555
		1000 0111 1010 1101 0110
		0101 0101 0101 0101 0101
		---- ---- ---- ---- ----
		1101 0010 1111 1000 0011 -> D2F83
		0101 0101 0101 0101 0101
		---- ---- ---- ---- ----
		1000 0111 1010 1101 0110 -> 87AD6
	q3: 逻辑运算，2 - 3
		3 -> 0011
		-3 -> 1101
		0010		0010
		1101		1101
	 (xor)------ (and)------
		1111	    0000
		=> -1
		
正数带着符号一起取反+1得到其相反数的补码
负数补码-1取反得到其相反数

每个程序的4g虚拟内存空间来由：
	内存地址占4byte（指针），每个内存地址存放1byte数据
	地址范围：0x0000 0000 ~ 0xffff ffff
	地址总数：ffff ffff + 1 = 1 0000 0000
	总内存大小：1 0000 0000 * 8 = 0x8 0000 0000 bit -> 4g
	
通用寄存器（可任意修改）
	32bit: eax, ecx, edx, ebx, esp, ebp, esi, edi
	16bit: ax, cx, dx, bx, sp, bp, si, di
	8bit:  al, ah, cl, ch, dl, dh, bl, bh
	
mov指令（一定要注意数据长度一致）
	mov reg, num
	mov reg, reg
	mov reg, mem
	mov mem, num
	mov mem, reg
	使用mem一定要指定清楚数据宽度(byte, word, dword)，mem可以是一个表达式
	只有mem可以写成表达式，其他都不行！
	
mov targ, src
	1.src可以imm/reg/mem
	2.targ可以reg/mem
	3.targ和src宽度需一致
	4.targ和src不能同时为mem（大多数汇编不支持mem到mem）
	
mem格式：
	1.[立即数]
	2.[8个通用reg]
	3.[reg + 立即数]
	4.[reg + reg * 1/2/4/8]
	5.[reg + reg * 1/2/4/8 + 立即数]
	
16位段寄存器
	ds：数
	es：edi/esi
	ss/ds：ebp/esp
	
push/pop imm/reg16/reg32/mem16/mem32
pushad/popad 按 eax,ecx,edx,ebx,esp,ebp,esi,edi 顺序保存寄存器
	
大多数windows程序是 小端存储：数据低位在内存低位，数据高位在内存高位
arm上大多数是 大端

add, sub, and, or, xor运算的结果会存到第一个操作数中，not也是存在操作数中

copy mem到mem（常和rep用于批量copy内存）
	movsb == movs byte ptr es:[edi], byte ptr ds:[esi]
		edi，esi自动加/减1
	movsw == movs word ptr es:[edi], word ptr ds:[esi]
		edi，esi自动加/减2
	movsd/movs == movs dword ptr es:[edi], dword ptr ds:[esi]
		edi，esi自动加/减4
			
copy reg(eax)到mem（常和rep用于批量将内存置为同一个值）
	stosb == stos byte ptr es:[edi]
		al -> [edi], edi自动加/减1
	stosw == stos word ptr es:[edi]
		ax -> [edi], edi自动加/减2
	stosd/stos == stos dowrd ptr es:[edi]
		eax -> [edi], edi自动加/减4
		
rep：ecx表示执行次数，执行完毕后ecx会为0
	eg: rep movsd/stosd
	
数据栈使用是从大到小，相关指令：push，pop（仅word和dword，会修改esp）

修改eip：
	1.jmp
	2.call ==>
		push eip+x
		jmp xx
	3.retn/ret ==>
		pop eip

efl是标志寄存器，32位，每一位都有自己的意义，efl常用位：
	od__ sz_a _p_c
	
	[0]c: 算数运算结果在最高位 进位/借位 溢出 置1，否则0（无符号数是否溢出）
		受数据宽度影响
	[2]p: 运算结果末尾字节中1的个数为偶数 置1，否则0
	[4]a: 存在辅助进位 置1，否则0
	[6]z: 运算结果为0 置1，否则0
		cmp == sub，cmp不修改操作数
		test == and，test不修改操作数
		xor eax, eax 和 mov eax, 0 区别：xor会改变标志寄存器
	[7]s: 运算结果第一位是否1
	[10]d: 方向（movs, cmps, scas, lods, stos）
		std -> 1
		cld -> 0
	[11]o: 有符号数运算结果是否溢出，溢出 置1，否则0
		受数据宽度影响
		
--------------
	q1.仅c
		mov al, 0xe0
		add al, 0x21
	q2.仅p
		mov ax, 0x8
		add ax, 0x1
	q3.仅a
		mov ax, 0xfe
		add ax, 0x3
	q4.仅s
		mov ax, 0xfffd
		add ax, 0x1
	q5.仅o
		mov ax, 0x8001
		sub ax, 0x1000
			
jcc
	je,jz		z=1
	jne,jnz		z=0
	js			s=1
	jns			s=0
	jp,jpe		p=1
	jnp,jpo		p=0
	jo			o=1
	jno			o=0
	//无符号数，below，above
	jb,jnae		
	jnb,jae
	jbe,jna
	jnbe,ja
	//有符号数，less，greater
	jl,jnge		
	jnl,jge
	jle,jng
	jnle,jg
	
push ebp
mov ebp, esp
对于函数来说:
	ebp-4		//局部变量1
	ebp			//旧ebp
	ebp+4		//返回地址（在函数内修改此值，直接影响函数执行完后的返回地址！拿到这个值也很简单：第一个局部变量的地址+?）
	ebp+8		//参数1
	ebp+C		//参数2
	
--------------
	q.任意进制的任意数转换
	void show(int fmt, int num) {
		int tmp = num;
		int size = 0;
		while (tmp != 0) {
			tmp /= fmt;
			size++;
		}
		size = size == 0 ? 1 : size;

		char* rs = new char(size);
		int tailIdx = size - 1;
		int left;
		while (true) {
			left = num % fmt;
			num = num / fmt;
			//printf("%d ", left);
			rs[tailIdx--] = left;
			if (num == 0) {
				break;
			}
		}
		
		for (int i = 0; i < size; i++) {
			int n = rs[i];
			if (n < 10) {
				printf("%d", rs[i]);
			}
			else {
				printf("%c", (char)(n - 10 + 65));
			}
		}
	}


裸函数，编译器不会为此函数生成任何代码，所以从分配内存到ret返回函数都要自己写
int __declspec(naked) nakeF(int x, int y) {
    __asm {
        push ebp
        mov ebp, esp
        sub esp, 0x40
        push esi
        push edi
        push ebx
        lea edi, dword ptr [ebp - 0x40]
        mov eax, 0xCCCCCCCC
        mov ecx, 0x10
        rep stos dword ptr es:[edi]

        mov eax, dword ptr ss:[ebp + 0x8]
        add eax, dword ptr ss:[ebp + 0xC]

        pop ebx
        pop edi
        pop esi
        mov esp, ebp
        pop ebp
        ret
    }
}

几种调用规范
	__declspec(naked) 	外平栈
	__cdecl				外平栈
	__stdcall			内平栈
	__fastcall			ecx/edx传前两个参数，后续参数依次入栈，内平栈


char 	1byte
short	2byte
int		4byte
long	4byte
float 	4byte
-----------------浮点数作业	
	12.5(4148 0000)
		12 -> 1100
		0.5
			0.5*2	1.0		1
		1100.1 -> 1.1001	3-1=2
		0 0-0000000 00000000-00000000-0000000
		0 1-0000010 10010000-00000000-0000000
		01-00 0001 0100 1000 0-000 0000 0-000 0000
		->4148 0000
	-6.7(C0D6 6666)
		6 -> 0110
		0.7
			0.7*2	1.4		1
			0.4*2	0.8		0
			0.8*2	1.6		1
			0.6*2	1.2		1
			0.2*2	0.4		0
			0.4*2	0.8		0110
		0110.101100110...	1.101 01100110...	2-1=1
		0 0-0000000 00000000-00000000-0000000
		1 1-0000001 10101100-11001100-1100110
		11-00 0000 1101 0110 0-110 0110 0-110 0110
		->C0D6 6666
	0.95(3F73 3333)
		0.95
			0.95*2	1.9		1
			0.9*2	1.8		1
			0.8*2	1.6		1
			0.6*2	1.2		1
			0.2*2	0.4		0
			0.4*2	0.8		0
			0.8*2	1.6		1100
		0.111100 11001100...	1.11100 11001100...	-1-1=-2 -> FE -> 1-1111110
		0 0-0000000 00000000-00000000-0000000
		0 0-1111110 11100110-01100110-0110011
		00-11 1111 0111 0011 0-011 0011 0-011 0011	
		->3F73 3333
	-0.32(BEA3 D70A)
		0.32
			0.32*2	0.64	0
			0.64*2	1.28	1
			0.28*2	0.56	0
			0.56*2	1.12	1
			0.12*2	0.24	0
			0.24*2	0.48	0
			0.48*2	0.96	0
			0.96*2	1.92 	1
			
			0.92*2	1.84	1
			0.84*2	1.68	1
			0.68*2	1.36	1
			0.36*2	0.72	0
			0.72*2	1.44	1
			0.44*2	0.88	0
			0.88*2	1.76	1
			0.76*2	1.52	1
			
			0.52*2	1.04	1
			0.04*2	0.08	0
			0.08*2	0.16	0
			0.16*2	0.32	0
			0.32*2	0.64	0101..
			
		0.0101 0001 1110 1011-1000 0101 0001 1110
		  1.01 0001 1110 1011 1000 0101 0001 1110		-2-1=-3 -> FD -> 1-1111101
		0 0-0000000 00000000-00000000-0000000
		1 0-1111101 01 0001 1110 1011 1000 0101 0001 1110
		10-11 1110 1010 0011 1101 0111 0000 1010 0011 110
		->BEA3 D70A
		
----------------------逆向CallingConvention
	int __fastcall f(int a, int b, int c, int d, int e){
		int v1 = f2(a, b, c);	//std int x+y+z
		int v2 = f3(a, b);		//cd int x+y
		int rs = f3(v1, v2)
		return rs;
	}
	int rs = f(1, 3, 4, 6, 7);
	printf("%d", rs);
	

ascii表本身只包含字符：0~127
扩展ascii表是不同语言对ascii的扩展，比如中文的扩展表成为gb2312：前128个字符和原ascii表一样，后128字符用某两个代表一个汉字
gb2312用 两个字节表示一个汉字，且gb2312用的单字节都是1xxx-xxxx
扩展acsii的缺点就是不同语言会出现 同符号表示不同字符，导致乱码
Unicode解决上述问题