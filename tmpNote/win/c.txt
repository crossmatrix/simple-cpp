全局变量 只要程序不重新构建，地址就是固定不变的
	1.全局变量即使不指定，也有自己的初始值（用struct和int测试）
	2.编译时已经确定好内存地址和大小，因此无论哪次运行，其地址都一样
	3.外挂中也称为"基址"
局部变量
	1.运行时由函数内部申请内存
	2.地址不固定

分析函数步骤：
	1.local
	2.arg
	3.global
	4.progress

---------------------
	int g;
	voif f(a1, a2){
		v1 = g;
		v2 = 2;
		if(a1 >= a2){
			v2 += 1;
		}
		if(a1 < a2){
			g = v2;
		}else{
			g = v1 + v2;
		}
	}
---------------------
	int f(int a1, int a2, int a3){
		int v1 = 0;
		int v2 = 1;
		int v3 = 2;
		if(a1 <= a2){
			v1 = v2 - 1;
		}else if(a2 >= a3){
			v1 = v3 + 1;
		}else if(a1 > a3){
			v1 = v2 + v3;
		}else{
			v1 = &(v2 + v3 - 1);
		}
		return v1 + 1;
	}
	
	lea除了取地址之外，还有一个用途，直接返回寄存器运算的结果值，eg
		int v1 = v2 + v3 - 1;
		mov eax,dword ptr [ebp-20h]  
		mov ecx,dword ptr [ebp-14h]  
		lea edx,[ecx+eax-1]  
		mov dword ptr [ebp-8],edx


if else反汇编
	cmp
	jcc xxx
	...
	jmp
	xxx: ...
	
movsx/movzx targ, src
	把src扩展到targ中
	reg, reg
	reg, mem
movsx：根据src首位扩展
movzx：无符号扩展，直接补0
	
char是c原生类型，默认是有符号的，byte是cpp后来补充的类型，完整定义是unsigned char
	byte v1 = 0xff;	
	int i1 = v1;
	printf("%d\n", i1);	//255
	char v2 = 0xff;
	int i2 = v2;
	printf("%d\n", i2);	//-1
	
还是那个问题，计算机只存储数据，把数据当成有符号还是无符号取决于使用者本人
	char a = -1;
	unsigned char b = a;	//255

for反汇编 for(exp1; exp2; exp3){}
	exp1
	jmp exp2
	exp3
	exp2
	...
	jmp exp3

int a[5];					//unknow
int a[5] = {};				//00000
int a[5] = {0};				//00000
int a[5] = {1};				//10000
int a[5] = {1, 2, 3, 4, 5};	//12345
int a[] = {1, 2, 3, 4, 5};	//12345

现代32为内存字节对齐：
void autoSize() {
	//C0
	//int a;		//CC
	//int b;		//D8
	
	//char a;		//CC
	//char b;		//D8

	//long long a;	//D0

	/*
		1.默认没有任何变量，编译器为函数申请C0大小内存
		每个变量按C的倍数申请内存
		总申请大小：C0 + n * C
		小于等于int的类型会根据字节对齐扩展存储宽度：1/2/4byte -> 12byte
		2.8byte -> 16byte
		3.总结：基础类型的对齐需要预留8字节！
	*/

	int a[10] = { 0 };
	char b[10] = { 0 };
	short c[10] = { 0 };

	/*
		3.数组在内存空间连续存储
		与普通变量不同的是，不会根据字节对齐扩展
	*/
}

struct细节
	直接将struct作为参数或返回值，从汇编层面分析，都可以看出是将struct完全拷贝使用，效率不高，所以推荐使用struct的指针
	St a = {};	这是对a初始化
	St a; a = {};	这将在另一内存空间初始化一个St，然后逐值拷贝给a

结构体字节对齐：这是cpu要求，按这种方式存储，cpu查找效率最高（空间换时间）
	1.第一个成员在结构体偏移量为0的地址处
	2.其他成员变量要对齐到<对齐数>的整数倍的地址处
		对齐数 = 编译器默认的对齐数与该成员大小的较小值（vs中默认值为8）
	3.结构体总大小为最大对齐数（每个成员都有一个对齐数）的整数倍
	4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍
	
sizeof(type/value): 返回所占内存空间大小（单位：字节）
	struct st1
	{
		bool a;
		char ss[10];
		int b;
	};
	printf("%d\n", sizeof(char));	//1
	printf("%d\n", sizeof(short));	//2
	printf("%d\n", sizeof(int));	//4
	printf("%d\n", sizeof(bool));	//1
	printf("%d\n", sizeof(long));	//4
	printf("%d\n", sizeof(float));	//4
	printf("%d\n", sizeof(double));	//8
	printf("%d\n", sizeof(st1));	//15 -> 16
	int arr1[10];
	short arr2[10];
	char arr3[10];
	printf("%d\n", sizeof(arr1));	//40
	printf("%d\n", sizeof(arr2));	//20
	printf("%d\n", sizeof(arr3));	//10
	
	struct T1
	{
		char a;
		int b;
		char c;
	};
	struct T2
	{
		char a;
		__int64 b;
		int c;
	};
	printf("%d\n", sizeof(T1));		//6 -> 12
	printf("%d\n", sizeof(T2));		//13 -> 24

指针：
	1.只要是指针，宽度都是4 byte
	2.指针++, --, +, -变化：指针指向类型的大小（去掉一个*的大小）
		eg:
			char* a = (char*)1; a++;		//a: 2
			int* b = (int*)1; b++; 			//b: 5
			char** c = (char**)1; c++;		//c: 5
			int** d = (int**)1; d++;		//d: 5
			char*** e = (char***)1; e++;	//e: 5
			int*** f = (int***)1; f++;		//f: 5
	3.指针只能做加减法
		p +- num = p +- sizeof(p point type) * num
	4.指针是无符号数（这意味着指针比较是ja/jb）
	5.指针与字符串
		1.char s1[] = {'a', 'b', 'c', '\0'};
			s1内存可修改
		2.char s2[] = "abc";
			"abc"存在常量区，s2是从常量区copy过来的，s2内存可修改，并且会自动补'\0'
		3.char* s3 = "abc";
			"abc"存在常量区，s3是此常量首地址的一个指针引用，所以s3不可修改
			这也就是为什么推荐写为：const char* s = "xxx";
			char* !<- const char*
			const char* <- char* 
		4.const char* v, v可变，v指向内容不可变
			const char* arr[] = {"aa", "bb"};
			char arr2[][5] = {"aa", "bb"};
			arr[0] = "cc";
			//arr[0][0] = 'b';
			//arr2[0] = "cc";
			arr2[0][0] = 'b';
			
			char a[] = "123";
			a[0] = '2';
			//a = "456";
			const char* b = "123";
			//b[0] = '2';
			b = "4567";
			b = a;
			//a = b;
	6.多级指针
		*(p+i) = p[i]
		*(*(p+i)+k) = p[i][k]
		...
		Type ***v = v[0][0][0]
		---------------------
			char* p1 = 0;
			char** p2 = 0;
			char*** p3 = 0;
			char c;
			c = *(p1 + 1);
			c = *(*(p2 + 1) + 2);

			//+4, +8, +3
			c = *(*(*(p3 + 1) + 2) + 3);

			int*** p4 = 0;
			//+4, +8, +12
			int v = *(*(*(p4 + 1) + 2) + 3);
	7.数组指针（一个指向数组的指针）
		int arr[] = {10, 20, 30};
		int(*p2)[3] = &arr;
		printf("%d\n", (*p2)[1]);
		//p2和*p2值相同，但是类型不同，因此运算结果也不同！
		//p2: +12
		//*p2: +4
		printf("--> %d %d\n", p2, *p2);
		printf("--> %d %d\n", p2 + 1, (*p2) + 1);	//p2[1] (*p2)[1]
		
		int(*p)[2][3] = 0;
		//(2 * 6 + 2 * 3 + 2) * 4 = 80
		int* v = *(*(p + 2) + 2) + 2;
		printf("%d", v);
		
		void main() {
			int(*a)[5];
			char(*b)[3];
			int(*c)[2][2];
			char(*d)[3][3][3];

			//4 4 4 4
			printf("%d %d %d %d\n", sizeof(a), sizeof(b), sizeof(c), sizeof(d));

			a = (int(*)[5])1;
			b = (char(*)[3])1;
			c = (int(*)[2][2])1;
			d = (char(*)[3][3][3])1;

			a++;
			b++;
			c++;
			d++;

			//21 4 17 28
			printf("%d %d %d %d\n", a, b, c, d);	
			
			int arr[] = {1, 2, 3};
			int(*pArr)[3] = &arr;
			printf("%d %d %d\n", (*pArr)[0], (*pArr)[1], (*pArr)[2]);
			printf("%d %d %d\n", pArr[0][0], pArr[0][1], pArr[0][2]);
		}
	8.函数指针
		eg: int (__cdecl *f)(int, int);
			f = ...
			int result = f(10, 20);
		函数指针不能进行+-操作！因为函数本身的宽度是不确定的

位运算（无符号数的左移右移都是逻辑运算）
	1100 0001 0xc1
	0000 0100 0x04
	1111 0000 0xf0
	0011 0000 0x30
	//算数左移和逻辑左移效果相同：低位补0
	mov al, 0xC1
	sal/shl al, 2	-> cf:1 0x04
	
	//算数右移，高位补符号位
	mov al, 0xC1
	sar al, 2		-> cf:0 0xF0
	
	//逻辑右移，高位补0
	mov al, 0xC1
	shr al, 2		-> cf:0 0x30
	
	//循环位移
	rol
	ror
	
	//带cf的循环位移
	rcl
	rcr

#define xx yy
	宏定义：在编译前完全替换，所以yy可以是任何形式的内容
	带参宏：本质也是替换，并不是真正函数
		eg: #define MAX(x, y) ((x) > (y) ? (x) : (y))
	良好的宏习惯：带参时应加上()避免不必要的错误
	行尾无分号
	多行宏：行末尾加\
		eg: #define A for(int i = 0; i < 5; i++){\
				printf("%d ", i);\
			}\
	何时用宏：定义一些比较简短的说明
	
#include 包含文件
	"": 找项目中自己编写的文件，如果不存在再找外部引入文件
	<>: 只找找外部引入文件
	重复包含：
		高版本 	#pragma once
		
		通用	#ifndef xxx
				#define xxx
				...
				#endif

--------------------------------
	void copyBinFile() {
		FILE* fp = fopen("E:/code/cpp/test1/src/notepad.exe", "rb");
		if (fp != 0) {
			fseek(fp, 0, SEEK_END);
			long size = ftell(fp);
			byte* box = (byte*)malloc(size);
			memset(box, 0, size);
			
			fseek(fp, 0, SEEK_SET);
			fread(box, 1, size, fp);
			fclose(fp);

			FILE* wp = fopen("E:/code/cpp/test1/src/new.exe", "wb");
			fwrite(box, sizeof(byte), size, wp);
			fclose(wp);

			free(box);

			printf("write: %d", size);
		}
		else {
			printf("file not found");
		}
	}
	
	1.fopen: 如果处理二进制文件，需要加b（rb或wb）
	2.fseek: 设置当前游标
	3.ftell: 获取当前游标
	4.fread
	5.fwrite