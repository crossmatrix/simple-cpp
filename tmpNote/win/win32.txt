多字节：扩展asc，无前缀，char
宽字节：Unicode，前缀L，w_char
TCHAR在不同环境下自动转换类型，TEXT

宽字符的打印
	#include <locale.h>
	setlocale(LC_ALL, "");
	wprintf
	
console <-> win32
	1.c++ - 预处理器: _CONSOLE - _WINDOWS
		取消unsafe代码警告也是在这里添加：_CRT_SECURE_NO_WARNINGS
	2.链接器 - 系统：/SUBSYSTEM:CONSOLE - /SUBSYSTEM:WINDOWS
	
Win32程序没有报错，可以通过GetLastError查到错误号

win32日志函数
	.h
	void __cdecl OutputDebugStringF(const char *format, ...); 
	#ifdef _DEBUG  
	#define DbgPrintf   OutputDebugStringF  
	#else  
	#define DbgPrintf  
	#endif 

	.cpp
	void __cdecl OutputDebugStringF(const char *format, ...)  
	{  
		va_list vlArgs;  
		char    *strBuffer = (char*)GlobalAlloc(GPTR, 4096);  
		va_start(vlArgs, format);  
		_vsnprintf(strBuffer, 4096 - 1, format, vlArgs);  
		va_end(vlArgs);  
		strcat(strBuffer, "\n");  
		OutputDebugStringA(strBuffer);  
		GlobalFree(strBuffer);  
		return;  
	}  

反汇编下断消息循环
	1.找到WinMain，WinMain 4参数特征
	2.找MsgLoop，RegisterClass查看WNDCLASS的wndProc
		WNDCLASS{
			2: lpfnWndProc
			5: hInstance
			10: lpszClassName
		}
	3.MsgLoop下条件断: [esp+8] == WM_X && [esp+0xC] == ?
		esp: 返回地址
		esp+4: HWND hwnd
		esp+8: UINT uMsg
		esp+C: WPARAM wParam
		esp+10: LPARAM lParam

win32中所有控件都是窗口，创建窗口通常需要指定父窗口，子窗口的事件最终会传到父窗口的消息循环中(WM_COMMAND)
创建子窗口是hMenu的意义是指定窗口编号，后续消息处理可通过此编号区分消息类型

查看class信息（GetClassName -> GetClassInfo）
	TCHAR clsName[10];
	GetClassName(wnd1, clsName, 10);
	WNDCLASS wndCls;
	GetClassInfo(hInstance, clsName, &wndCls);
	logW(L">>%s\n", clsName);
	log("%x\n", wndCls.lpfnWndProc);


------------------------------
#pragma once
#ifndef _DGB_H
#define _DGB_H

void __cdecl DbgLog(const char* format, ...);
void __cdecl DbgLogW(const wchar_t* format, ...);

#ifdef _DEBUG
#define log DbgLog
#define logW DbgLogW
#else
#define DbgLog
#define DbgLogW
#endif

#endif // !_DGB_H

------------------------------
#include "dbg.h"
#include <Windows.h>
#include <stdio.h>

void __cdecl DbgLog(const char* format, ...) {
    va_list vlArgs;
    char* strBuffer = (char*)GlobalAlloc(GPTR, 4096);
    va_start(vlArgs, format);
    _vsnprintf(strBuffer, 4096 - 1, format, vlArgs);
    va_end(vlArgs);
    strcat(strBuffer, "\n");
    OutputDebugStringA(strBuffer);
    GlobalFree(strBuffer);
    return;
}

void __cdecl DbgLogW(const WCHAR* format, ...) {
    va_list vlArgs;
    WCHAR* strBuffer = (WCHAR*)GlobalAlloc(GPTR, 4096);
    va_start(vlArgs, format);
    _vsnwprintf(strBuffer, 4096 - 1, format, vlArgs);
    va_end(vlArgs);
    lstrcatW(strBuffer, L"\n");
    OutputDebugStringW(strBuffer);
    GlobalFree(strBuffer);
    return;
}
	
------------------------------

#include <windows.h>
#include <stdio.h>
#include <locale.h>
#include "dbg.h"

//void main() {
//	setlocale(LC_ALL, "");
//
//	char c1 = '中';
//	wchar_t c2 = L'中';
//	TCHAR c3 = TEXT('中');
//
//	char s1[] = "中国";
//	wchar_t s2[] = L"中国";
//	TCHAR s3[] = TEXT("中国");
//
//	printf("%s, %d\n", s1, strlen(s1));
//	wprintf(L"%s, %d\n", s2, wcslen(s2));
//
//	printf("be called");
//}

namespace t1 {
	void test1() {
		log("%s %d\n", "haha", 123);
		MessageBox((HWND)1, 0, 0, 0);
		DWORD err = GetLastError();
	}

	LRESULT CALLBACK MsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
		switch (uMsg)
		{
		case WM_COMMAND:
		{
			log("WM_COMMAND: %d %d\n", wParam, lParam);
			switch (wParam)
			{
			case 1001:
			{
				log("be called 1, wnd: %d\n", lParam);
				break;
			}
			case 1002:
			{
				log("be called 2, wnd: %d\n", lParam);
				break;
			}
			case 1003:
			{
				log("be called 3, wnd: %d\n", lParam);
				break;
			}
			default:
				break;
			}
			break;
		}
		case WM_CREATE:
		{
			log("WM_CREATE %d %d\n", wParam, lParam);
			CREATESTRUCT* createst = (CREATESTRUCT*)lParam;
			log("CREATESTRUCT %s\n", createst->lpszClass);
			break;
		}
		case WM_MOVE:
		{
			log("WM_MOVE %d %d\n", wParam, lParam);
			POINTS points = MAKEPOINTS(lParam);
			log("X Y %d %d\n", points.x, points.y);
			break;
		}
		case WM_SIZE:
		{
			log("WM_SIZE %d %d\n", wParam, lParam);
			int newWidth = (int)(short)LOWORD(lParam);
			int newHeight = (int)(short)HIWORD(lParam);
			log("WM_SIZE %d %d\n", newWidth, newHeight);
			break;
		}
		case WM_DESTROY:
		{
			log("WM_DESTROY %d %d\n", wParam, lParam);
			PostQuitMessage(0);
			break;
		}
		case WM_KEYUP:
		{
			//log("WM_KEYUP %d %d\n", wParam, lParam);
			break;
		}
		case WM_KEYDOWN:
		{
			log("WM_KEYDOWN %d %d\n", wParam, lParam);
			switch (wParam)
			{
			case 65:
			{
				WCHAR c[10] = {};
				_itow(wParam, c, 10);
				const TCHAR* h = TEXT("suc1");
				MessageBox(0, c, h, 0);
				break;
			}
			case 70:
			{
				WCHAR c[10] = {};
				_itow(wParam, c, 10);
				const TCHAR* h = TEXT("suc2");
				MessageBox(0, c, h, 0);
				break;
			}
			default:
			{
				const TCHAR* h = TEXT("error");
				MessageBox(0, h, h, 0);
				break;
			}
			}
			break;
		}
		case WM_LBUTTONDOWN:
		{
			log("WM_LBUTTONDOWN %d %d\n", wParam, lParam);
			POINTS points = MAKEPOINTS(lParam);
			log("WM_LBUTTONDOWN %d %d\n", points.x, points.y);
			break;
		}
		default:
			return DefWindowProc(hwnd, uMsg, wParam, lParam);
		}
		return 0;
	}

	void CreateSubWnd(HINSTANCE hInstance, HWND hwnd) {
		HWND wnd1 = CreateWindow(
			TEXT("Button"), TEXT("btn1"), 
			WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
			50, 20,
			100, 30,
			hwnd,
			(HMENU)1001,
			hInstance,
			NULL
		);
		HWND wnd2 = CreateWindow(
			TEXT("Button"), TEXT("btn2"),
			WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_AUTOCHECKBOX,
			50, 60,
			100, 30,
			hwnd,
			(HMENU)1002,
			hInstance,
			NULL
		);
		HWND wnd3 = CreateWindow(
			TEXT("Button"), TEXT("btn2"),
			WS_CHILD | WS_VISIBLE | BS_RADIOBUTTON,
			50, 100,
			100, 30,
			hwnd,
			(HMENU)1003,
			hInstance,
			NULL
		);

		TCHAR clsName[10];
		GetClassName(wnd1, clsName, 10);
		WNDCLASS wndCls;
		GetClassInfo(hInstance, clsName, &wndCls);
		logW(L">>%s\n", clsName);
		log("%x\n", wndCls.lpfnWndProc);
		log("%d %d %d\n", wnd1, wnd2, wnd3);
	}

	void test2(HINSTANCE hInstance) {
		TCHAR clsName[] = TEXT("MyWndCls");
		WNDCLASS wndCls = {};
		wndCls.lpfnWndProc = MsgLoop;
		wndCls.hInstance = hInstance;
		wndCls.lpszClassName = clsName;
		wndCls.hCursor = LoadCursor(NULL, IDC_ARROW);
		wndCls.hbrBackground = (HBRUSH)COLOR_MENU;
		RegisterClass(&wndCls);

		TCHAR wndName[] = TEXT("fst wnd");
		HWND hwnd = CreateWindow(clsName, wndName, WS_OVERLAPPEDWINDOW, 700, 500, 500, 350, NULL, NULL, hInstance, NULL);
		if (hwnd == NULL) {
			return;
		}
		CreateSubWnd(hInstance, hwnd);
		ShowWindow(hwnd, SW_SHOW);

		MSG msg;
		while (GetMessage(&msg, NULL, 0, 0)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}


}
using namespace t1;

int WINAPI WinMain(
	_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPSTR lpCmdLine,
	_In_ int nShowCmd
) {
	test2(hInstance);

	return 0;
}