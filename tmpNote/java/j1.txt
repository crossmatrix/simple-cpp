effective java
深入理解java虚拟机
操作系统

jdk：java开发工具包
	jre + java开发工具(eg: java, javac, javap, javadoc)
jre：java运行环境
	jvm + java核心类库
	
jdk主要版本：java8，java11
jdk配置：安装完jdk后，环境变量添加 JAVA_HOME = jdk安装的主目录，系统path添加 %JAVA_HOME%\bin
jdk配置成功：cmd -> java -version -> javac -version
关闭jdk自动更新

java执行步骤：java源文件 --javac(compile)--> class字节文件 --java(jvm run)--> 结果

windows的cmd默认是GBK字符集，所以如果用cmd手动javac编译java文件，需要把java的文件字符集也设置成GBK（sublime - 文件 - 设置文件编码 - GBK）
但是如果用智能ide的话，一般都保存为UTF-8

java文件说明：
1.文件后缀为.java
2.程序入口函数为 public static void main(String[] args){...}
3.一个文件中有几个类编译后就会有几个class文件
4.一个文件中 最多！一个public类，其他类个数不限（也就是说一个java文件可以一个public类也没有）
5.一个文件中如果包含了public类，则文件名必须和这个public类名一致
6.非public类也可以有static main方法（所以每个类都可以有main方法）

转义字符：
	"\r"是回车，指的是将光标移至当前输入位置的行首(eg: "abc\rd" -> "dbc")
	"\r\n" = "\n\r" = "\n"

注释：
1.单行 //
2.多行 /* xxx */
3.文档
/**
 * @author naiwoma
 * @version 10.0.0
 */
javadoc -d xxdir -author -version Hello.java

cmd常用：cls, cd, md, rd, copy, move, del, echo（可创建并写入文件 覆盖：">"，追加：">>"，写入nul就是创建空文件）, type（打印文件）

-----------------------
值类型：
	byte(1) 	-2^7 ~ (2^7 - 1)
 	short(2) 	-2^15 ~ (2^15 - 1)
	int(4)		-2^31 ~ (2^31 - 1)
	long(8)		-2^63 ~ (2^63 - 1)
		eg: 100L
	float(4)
		eg: 100.1F
	double(8)
	char(2)
	bool(1)
引用类型：
	class, interface, array
小数的默认类型是double，整数的默认类型是int

小数的比较不要使用==，String的比较用equals
	float f3 = 2.7F;
	float f4 = 8.1F / 3;
	//f3 == f4
	double d3 = 2.7;
	double d4 = 8.1 / 3;
	//d3 != d4
	处理方案：Math.abs(d3 - d4) < 0.0001

java api文档:
	www.matools.com
	
常用字符编码：
ascii：1个字符1个字节
unicode：1个字符2个字节，兼容ascii
utf-8：英文1字节，汉字3字节，对unicode的改进
gbk：英文1字节，汉字2字节

java的真假判断只有boolean，不能0，不能null

基本数据类型自动转换（可从小类型跨到大类型）：
	1.char -> int -> long -> float -> double
	2.byte -> short -> int -> long -> float -> double
	3.多类型复合运算会自动转为容量最大类型
	4.char和byte/short不能转换，无论正逆
	5.byte, short, char三者任意组合（即便相同）都会转为int

-----------------------
强制类型转换：
	基础类型：
		小数转整数会直接丢弃小数位
		大容量数据转小容量数据，如果超过小容量的范围，则转换结果溢出
	类：
		类型不匹配时编译不过
		
字符串和基本类型转换：
	Integer.toString(100)
	Double.toString(100)
	100 + ""
	true + ""
	Integer.parseInt("100")
	Double.parseDouble("100")
	Boolean.parseBoolean("true")
	"abc".charAt(0)
	
a % b = a - (int)(a / b) * b 
	10 % 3 = 10 - 10 / 3 * 3  = 1
	10 % -3 = 10 - 10 / (-3) * (-3) = 1
	-10 % 3 = -10 - (-10) / 3 * 3 = -1
	-10 % -3 = -10 - (-10) / (-3) * (-3) = -1
	-10.5 % 3.2 = -10.5 - (int)(-10.5 / 3.2) * 3.2 = -10.5 - (-3) * 3.2 = -0.9

&, |可用于整数运算（位运算），也可用于bool运算（非短路逻辑运算）
&&, ||是短路逻辑运算

+=, -=, *=, /=, %=, ++, --：会进行强制类型转换
	byte a = 1;
	a = a + 2;		//int -> byte，类型错误
	a += 2;		//正确，等价于 a = (byte)(a + 2);
	
java中未赋初值的 局部变量 不能直接使用（没有默认值的概念）
类的属性 和 仅定义大小的数组 有默认值（数值型0，boolean型false，引用型null）

变量名：
	数字，字母，_，$（不能以数字开头）
	区分大小写
命名规范：
	包名：全小写
	类/接口：大驼峰
	变量：小驼峰
	常量：全大写，下划线分割

系统输入
	java.util.Scanner scanner = java.util.Scanner(System.in)
	String str = scanner.next()
	int num = scanner.nextInt()
	
java各种进制（0b/0B，0，0x/0X）
	int a = 10;
	int b = 0b1010;
	int c = 07;
	int d = 0xff;
	
在位运算中（&, |, ^, ~, >>, <<, >>>），计算过程使用补码，结果使用原码
正数：原，反，补一致
负数：
	原码 = 符号位是1（最高位），其余按正数计算原码
	反码 = 符号位不变，其余位取反
	补码 = 反码 + 1
eg：
	~2
		2（补）			00000000 00000000 00000000 00000010
		~2（补）		11111111 11111111 11111111 11111101		//最高位1，以负数方式计算原码
		~2（反）		11111111 11111111 11111111 11111100
		~2（原）		10000000 00000000 00000000 00000011
		结果：-3
		
	~-2
		-2（原）		10000000 00000000 00000000 00000010
		-2（反）		11111111 11111111 11111111 11111101
		-2（补）		11111111 11111111 11111111 11111110
		~-2（补）		00000000 00000000 00000000 00000001		//最高位0，以正数方式计算原码
		~-2（原）		00000000 00000000 00000000 00000001
		结果：1
		
	-3^3
		-3（原）		10000000 00000000 00000000 00000011
		-3（反）		11111111 11111111 11111111 11111100
		-3（补）		11111111 11111111 11111111 11111101
		3（补）			00000000 00000000 00000000 00000011
		-3^3（补）		11111111 11111111 11111111 11111110 	//最高位1，以负数方式计算原码
		-3^3（反）		11111111 11111111 11111111 11111101
		-3^3（原）		10000000 00000000 00000000 00000010
		结果：-2
	
	x >> y: x / (2的y次方)
	x << y: x * (2的y次方)
	
-----------------------
switch的case只能是常量或常量表达式
switch的case和比较量只能是byte, short, char, int, enum, String
嵌套循环中的break仅跳出本层循环

Math.random: double, [0, 1)

数组声明+定义方式：
	1.int[] arr = new int[3];
	2.int[] arr = new int[]{1, 2, 3};
	1.int[] arr = {1, 2, 3}
数组声明：
	int[] arr;
数组定义：
	arr = new int[3];
	arr = new int[]{1, 2, 3};
数组是引用类型，可置null
int[] arr = {}, arr.length为0
int[] t1 = new int[3];
	0
double[] t2 = new double[3];
	0.0
boolean[] t3 = new boolean[3];
	false
char[] t4 = new char[3];
	\u0000
String[] t5 = new String[3];
	null
	
二维数组声明+定义方式：
	1.int[][] arr = new int[3][];
	2.int[][] arr = new int[3][3];
	3.int[][] arr = new int[][]{{1, 2}, {3}, {4, 5, 6}};
	4.int[][] arr = {{1, 2}, {3}, {4, 5, 6}};
二维数组声明：
	int[][] arr;
二维数组定义：
	arr = new int[3][];
		这样的第二维默认值是null
		arr[0] == null
	arr = new int[3][3];
		二维数组的第二维可变
		arr[0] = new int[10];
	arr = new int[][]{{1, 2}, {3}, {4, 5, 6}};
	
-----------------------
类
	1.属性允许只声明，默认值同数组（局部变量不赋初值，直接使用会编译错误）
	2.对象和数组都可置null

对象创建在堆上，局部变量在栈上

函数的 返回值/形参 的 具体值和类型 只要类型能匹配就行（基础类型的自动转换，引用类型的多态）
	eg: double A(){ return 10; }
	
函数返回值不决定重载

函数的可变参数形式：void f(int... args)
其中args直接当数组使用
可变参数本质就是数组，所以实参也可以传递数组

可创建和属性名一样的局部变量，使用时按就近原则

一旦定义了自己的构造函数，系统默认构造函数就不再生效！！
如果任希望有无参构造器，需要手动创建
	
this除了常规用法，还能作为构造器调用，但有两个条件：
	1.只能在构造器内调其他构造器
	2.this(..)这种调用必须在构造器的第一行
	
基础类型的大写版是java的封装类
	Integer a = null;
	a = 10;
	int b = 10;
	System.out.println(a == 10);
	System.out.println(a == b);
	
-----------------------
https://www.cnblogs.com/along-technology/p/14767535.html
alt+f7
ctrl+b
(alt/ctrl)+shift+f9
(alt/ctrl)+shift+f10
shift+esc
ctrl+r
ctrl+alt+l
ctrl+q
ctrl+shift+n
alt+enter
alt+insert
ctrl+alt+space
alt+7
ctrl+alt+b
模板(Editor - Live Templates)
	main
	sout
	fori
	get
	set
	I
f7: 步入
f8: 步过
shift+f8: 跳出
f9: 下个断点
f7不能进入源码：Settings - Build - Debugger - Stepping - do not step into the class里去掉java.和javax.
集合类型设置：Debugger - Data Views - Java - 1.去掉hide null elements 2.去掉enable alternative view
	
-----------------------
package的本质就是用 不同的文件夹 来保存 类文件，所以创建package就是创建folder
一个java文件可以有多个class（但只能一个为public并和文件名相同），每个class都可以有自己的main入口
同包不能出现同名类
包名可以多级（.分隔）：数字，字母，_，.，不能数字开头，不能用关键字

java访问修饰符包括：public, protected, 默认, private
修饰 属性/方法：public, protected, 默认, private
修饰 类/接口：public, 默认

环境：本类，本包，子类，不同包
	public：所有可见
	protected：本类，本包，子类（即便不同包子类）
	默认：本包
	private：本类
	
继承
	1.构造器细节：
		1.默认情况下，子类的每一个构造函数第一行都会隐式调用 父类的 无参构造器
			super()
		2.这个隐式操作一旦被主动写出来就不会再触发一次
		3.主动写出来后可以明确指定调用 哪种版本的父类构造器
			super(10)
		4.构造器第一行只能为下面其中一种：
			1.无操作（隐式）
			2.super([xx])
			3.this([xx])
	2.所有类都共有基类Object
	3.java是单继承
	4.父类和子类可以定义相同的属性名，这些同名属性都存在于这个对象中！！
	访问属性时直接看 编译类型（属性看编译，方法看运行）
		eg:
		class A{public int v = 1;}
		class B extends A{}
		class C extends B{public int v = 3;}		
		B b = new C();
		System.out.println(b.v);	//1
		C c = (C)b;
		System.out.println(c.v);	//3
		C c2 = new C();
		System.out.println(c2.v);	//3
		
	5.方法重写：子类和父类的方法一样（同名同参，返回类型一样或是父类方法返回类型的子类）
		eg: 
		public class Base{
			public Object aa(int p1){...}
		}
		public class Sub extends Base{
			public String aa(int p1){...}
		}
	6.方法重写时子类方法不能缩小父类方法的访问权限
		5,6可以通过多态来理解
		
			范围		方法名		形参列表						返回类型										访问权限
	重载	本类		相同		类型，数量，顺序至少一个不同	无要求											无要求
	重写	父子类		相同		相同							子类与父类 重写方法的返回类型 相同 或是 子类型	子类不能缩小父类的访问权限
	
多态：提高代码复用性
	方法重写 + 父类引用子类实例
	属性没有重写！！
	
eg1:
	public class important1 {
		public static void main(String[] args) {
			Sub s = new Sub();
			System.out.println(s.score);    	//20
			s.display();                    	//20
			Base b = s;
			System.out.println(b == s);     	//true
			System.out.println(b.score);    	//10
			b.display();                    	//20
		}
	}
	class Base{
		public int score = 10;
		public void display(){
			System.out.println(score);
		}
	}
	class Sub extends Base {
		public int score = 20;
		public void display(){
			System.out.println(score);
		}
	}
	
eg2:
	public class important2 {
		public static void main(String[] args) {
			A a = new B();
			System.out.println(a.sum());
			System.out.println(a.sum1());

			//1.40 30
			//2.30 --  B.getI() + 10
			//3.20 --  A.i + 10
		}
	}
	class A{
		public int i = 10;
		public int sum(){
			return getI() + 10;
		}
		public int sum1(){
			return i + 10;
		}
		public int getI(){
			return i;
		}
	}
	class B extends A{
		public int i = 20;
		//2
	//    public int sum(){
	//        return getI() + 20;
	//    }
		//3
	//    public int sum1(){
	//        return i + 10;
	//    }
		public int getI(){
			return i;
		}
	}
	
-----------------------
==和equals区别
	==(两个比较内容需要类型兼容，不然编译错误)
		判断基本类型时 比较 值是否相等
		判断引用类型时 比较 是否是同一个对象
	equals
		是Object的方法，所以只能用于引用比较，子类可重写
		boolean Object.equals(Object obj) {
			return this == obj
		}
	eg:
		Integer i1 = new Integer(1000);
		Integer i2 = new Integer(1000);
		//i1 == i2	//false
		//i1.equals(i2)	//true
		
Object
	equals：通常用于子类重写；默认就是return this == obj
	hashcode: 为集合的各种Hash数据结构设计
	toString: 通常也是子类重写，默认返回"全类名+@+hex-hashCode"；print直接打印对象就会调用toString
	finalize: 主动gc或对象无任何引用被jvm自动gc前，会先调用对象的finalize方法；通常不处理这个方法
	getClass: 返回对象的 运行时 类

-----------------------
代码块：
	1.修饰符只能是 默认 和 静态
	2.静态代码块和静态属性 初始化同优先级，谁写在前谁先触发（类第一次加载时触发）
	3.普通代码块和成员属性 初始化同优先级，谁写在前谁先触发（每个对象创建都触发）
	4.创建对象 和 直接访问静态成员（static final例外） 都会 加载类的静态信息
	5.ctor(){
		super() 	//隐/显
		普通代码块和成员属性	//隐
		其他逻辑	//显
	}
	
static：
	1.可通过 类/对象 访问静态成员
	2.如果存在继承，仍可通过子类访问到父类静态成员
	
类的创建流程：
	1.加载类信息（仅一次，从父到子初始化 静态属性和静态代码块）
	2.堆空间分配内存
	3.构造器（隐/显 父类构造器->成员属性，普通代码块初始化->构造器真正代码初始化）
	4.返回对象到具体变量
	
final：
	类：不能被继承
	方法：不能被重写
	属性/局部变量：不能被修改（常量）
		定义位置：
			普通成员属性：1.声明就定义 2.构造器 3.普通代码块
			静态成员属性：1.声明就定义 2.静态代码块
	各种包装类，String都是final的
	
一个证明之前方法重写概念的例子：
	class D1{}
	class E1 extends D1{}
	class D{
		public final D1 f(D1 p){
			return null;
		}
	}
	class E extends D{
		//报错，因为这是重写
		//public D1 f(D1 p){
		//	return null;
		//}
		//public E1 f(D1 p){
		//	return null;
		//}
		//不报错，因为这是重载
		public D1 f(E1 p){
			return null;
		}
	}
	
abstract
	修饰：类，方法
	抽象类可以没有抽象方法，但有抽象方法一定是抽象类
	不能和private, final, static公用，可以和public，protected，默认修饰符共用（实现类不能缩小访问权限）
	
interface
	interface itf{
		int a = 10;				//接口可以有属性，必须赋值，已经包含public static final；这个属性属于 本接口，实现的类，类的实例
		void f1();				//接口通常要有抽象方法，已经包含public abstract；属于类实例（实现类必须声明public）
		default void f2(){		//接口可以实现普通方法，必须加default，已经包含public；属于类实例
			System.out.println("f2");
		}
		static void f3(){		//接口可以有静态方法，必须实现，已经包含public；只属于这个接口！！
			System.out.println("f3");
		}
	}
	
类只能 单继承类，但可以 多实现接口；接口之间可以多继承
	interface i1 extends i2, i3{}
	class A{}
	class B extends A implements i1, i2{}

内部类：
	位置：1.和属性同级 2.函数内部
	分类：局部内部类，成员内部类，匿名内部类，静态内部类
	成员内部类可以在其他外部类中创建：
		Outer.Inner obj = new Outer().new Inner()
	如果内部类和外部类出现同名成员，访问外部类成员：外部类.this.xxx
	匿名类都与继承相关（接口，抽象类，普通类），并且通常用于重写方法
		eg：
		public interface Flyable{
			void fly();
		}
		Flyable f = new Flyable(){
			public void fly(){...}
		};
	成员内部类被视作一个成员属性，因此可以被static修饰（java中没有静态类），如果内部类是静态的
		还可以在其他外部类这样创建：Outer1.Inner2 obj = new Outer1.Inner2();
		不能访问外部类的非静态成员

-----------------------
enum：
	枚举是一个继承java.lang.Enum的final类
	枚举值是对象，根据不同的构造器有不同的创建方式
	枚举值必须放在类的最前面，逗号分隔分号结尾
	Enum的常用方法：
		final name()
		final ordinal()
		valueOf("xxx")
		values()
	
	eg:
	enum Color{
		red, yellow(), Blue("a", 1), Green("b", 2);
		Color(){}
		Color(String p1, int p2){}
		...
	}

注解：
	@xxx
	原注解：注解的注解，@interface

[Throwable] extends Object implements Serializable
	1.Error: 致命，异常机制救不回来，程序直接挂掉
		eg: StackOverflowError, OutOfMemoryError...
	2.Exception: 可通过捕获使程序继续运行
		1.（编译异常）ClassNotFoundException, FileNotFoundException...
		2.RuntimeException: NullPointerException, ArithmeticException, IndexOutOfBoundsException, ClassCastException, NumberFormatException...
		
两种异常处理
	1.try{
		...
	}catch(Exception e){
		//异常时执行
		e.printStackTrace();
	}catch(..){
		//catch可以多个或者0个，子类异常写前，父类异常写后
		//如果一个也不写catch，就自动向上级抛异常
	}finally{
		//try完都会执行，通常用于释放资源，可以不写
	}
	
	2.throws
	将异常抛给上一级调用，如果上一级没有捕获，继续向上，直到jvm本身（退出程序，打印错误）
	运行时的异常处理默认是throws
		eg:
		void f() throws A-Exception, B-Exception {
			...
		}
	
	return是在整个try-finally之后才执行
	问题1
		try{
			exception..
		}catch(..){
			return 1;
		}finally{
			return 2;
		}
		//结果是2
	问题2
		i = 1
		try{
			i++;
			exception..
		}catch(..){
			return ++i;
		}finally{
			return ++i;
		}
		//结果是4
	问题3
		i = 1
		try{
			i++;
			exception..
		}catch(..){
			return ++i;
		}finally{
			sout(++i)
		}
		//先打印4，后返回3

自定义异常: MyException extends RuntimeException
主动抛出异常: throw new MyException()